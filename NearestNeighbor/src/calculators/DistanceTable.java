package calculators;

import java.util.HashMap;
import java.util.List;
import java.util.Set;

/**
 * Useful data structure for keeping distances between a set of pairs.
 * It does some tricky stuff but is ultimately backed by a 2D array.
 * It can recalculate all of its distances by using the various calculators.
 * We essentially manage all of the distance data so that the tree builder
 * merely serves as a thin pipe between the distance table and the tree.
 *
 * We don't store references to Taxa; only their autogenerated String IDs.
 * This allows us to generalize the distance table to other applications.
 */
public class DistanceTable {
    /** an upper triangular matrix of real distances */
    protected double[][] distances;

    /** an upper triangular matrix of biased distances to avoid duplication*/
    protected double[][] biasedDistances;

    /** an upper triangular matrix of uScores to avoid duplication*/
    protected double[] uScores;

    /** map that maps cluster auto generated names to rows/columns (same thing since square).
     * The best mental image is mapping names to columns.
    */
    protected  HashMap<String, Integer> clusterNamesToIndices;

    /** a calculator used for keeping our u-scores up to date*/
    protected UScoreCalculator uScoreCalculator;

    /** a calculator used for keeping our distances up to date*/
    protected DistanceCalculator distanceCalculator;

    /** a calculator used for keeping our biased distances up to date*/
    protected BiasedDistanceCalculator biasedDistanceCalculator;

    /** map that maps /deleted/ cluster auto generated to rows/columns*/
    protected HashMap<String, Integer> deletedClusterNamesToIndicies;

    /** a pointer used to indicate the next free element along the top of the matrix*/
    protected int nextFreeColumn;

    /** Creates a new distance table based off initial distances and IDs.
     *  The initial distances should be in lower triangular form as it makes indexing
     *  easier.
     */
    public DistanceTable(int[][] initialDistances, List<String> IDs) {
        int numberOfItems = IDs.size();

        // we have n taxa and (n - 1) internal node
        // (because the first step joins 2) for a total of
        // n + (n - 1) = 2n - 1 entries if we don't delete anything as we go along
        int size = 2 * numberOfItems - 1;

        // we initialize a *ragged* array to save space (and it will throw
        // helpful exceptions if my indexing code is bad)

        distances                     = new double[size][];
        biasedDistances               = new double[size][];

        // make a lower triangular array that includes the diagonals
        // we make enough room for all the groupings and initial elements
        for (int i = 0; i < size; i++) {
            distances[i]        = new double[i + 1];
            biasedDistances[i]  = new double[i + 1];
        }

        uScores                       = new double[size];

        clusterNamesToIndices         = new HashMap<String, Integer>();
        deletedClusterNamesToIndicies = new HashMap<String, Integer>();

        nextFreeColumn = numberOfItems; // we want +1, so one beyond last taxa (so no need to subtract one to make proper index)

        biasedDistanceCalculator = new BiasedDistanceCalculator();
        distanceCalculator       = new DistanceCalculator();
        uScoreCalculator         = new UScoreCalculator();

        // no initialize mappings from auto name to indicies
        int col = 0;
        for (String item_name : IDs) {
            // grab the IDs and stick them into the mapping from names to indicies
            clusterNamesToIndices.put(item_name, col);
            col++;
        }

        // fill in the initial lower triangular distance array
        // we are only filling in the first portion
        for (int i = 0; i < numberOfItems; i++) {

            for (int j = 0; j < distances[i].length; j++) {
                distances[i][j] = initialDistances[i][j];
            }
        }

        // since we have an initial set of distances, we should be able
        // to recalculate the uscores and the biased distances
        // ORDER IS IMPORTANT
        this.uScoreCalculator           .recalculate(this);
        this.biasedDistanceCalculator   .recalculate(this);
    }

    /**
     * Gets the distance between any two elements even if either or both have been
     * deleted in the past.
     * We allow people to get the distance between deleted elements for re-calculating the distances.
     */
    public double getDistance(String cluster1, String cluster2) {
        int c1Index = -1;
        int c2Index = -1;

        // now get cluster 1
        if (clusterNamesToIndices.containsKey(cluster1))
            c1Index = clusterNamesToIndices.get(cluster1);
        else {
            if (deletedClusterNamesToIndicies.containsKey(cluster1)) {
                c1Index = deletedClusterNamesToIndicies.get(cluster1);
            } else
                throw new ArrayIndexOutOfBoundsException("No entry for cluster: " + cluster1);
        }

        // now get cluster 2
        if (clusterNamesToIndices.containsKey(cluster2))
            c2Index = clusterNamesToIndices.get(cluster2);
        else {
            if (deletedClusterNamesToIndicies.containsKey(cluster2)) {
                c2Index = deletedClusterNamesToIndicies.get(cluster2);
            } else
                throw new ArrayIndexOutOfBoundsException("No entry for cluster: " + cluster2);
        }

        int[] indicies = flipToProperOrdering(c1Index, c2Index);

        return distances[indicies[0]][indicies[1]];

    }



    /** Tell our calculators to recalculate after the merge operation*/
    private void recalculateAfterMerge(String c1, String c2) {

        // ORDER is important!
        this.distanceCalculator.setClustersToMerge(c1, c2);
        this.distanceCalculator         .recalculate(this);

        this.uScoreCalculator           .recalculate(this);
        this.biasedDistanceCalculator   .recalculate(this);
    }

    /** get's the biased distance between these two clusters */
    public double getBiasedDistance(String cluster1, String cluster2) {

        // if we have neither
        if (! clusterNamesToIndices.containsKey(cluster1) || ! clusterNamesToIndices.containsKey(cluster2))
            return Double.MIN_VALUE;

        // make sure we are accessing the table properly
        int[] indicies = flipToProperOrdering(clusterNamesToIndices.get(cluster1), clusterNamesToIndices.get(cluster2));

        return biasedDistances[indicies[0]][indicies[1]];
    }

    /** sets the biased distance between two clusters */
    public void setBiasedDistance(String cluster1, String cluster2, double distance) {
        // if we have neither; break immediately
        if (! clusterNamesToIndices.containsKey(cluster1) || ! clusterNamesToIndices.containsKey(cluster2))
            return;


        // make sure we are accessing the table properly
        int[] indicies = flipToProperOrdering(clusterNamesToIndices.get(cluster1), clusterNamesToIndices.get(cluster2));

        biasedDistances[indicies[0]][indicies[1]] = distance;
    }

    /** sets the true distance between two clusters */
    public void setDistance(String cluster1, String cluster2, double distance) {



        // if we have neither; break immediately
        if (! clusterNamesToIndices.containsKey(cluster1) || ! clusterNamesToIndices.containsKey(cluster2))
            return;

        // make sure we are accessing the table properly
        int[] indicies = flipToProperOrdering(clusterNamesToIndices.get(cluster1), clusterNamesToIndices.get(cluster2));

        distances[indicies[0]][indicies[1]] = distance;
    }

    /** Merges two clusters together */
    public void mergeClusters(String cluster1, String cluster2) {
        // keep a pointer around
        deletedClusterNamesToIndicies.put(cluster1, clusterNamesToIndices.get(cluster1));
        deletedClusterNamesToIndicies.put(cluster2, clusterNamesToIndices.get(cluster2));

        // but remove from the current ones
        clusterNamesToIndices.remove(cluster1);
        clusterNamesToIndices.remove(cluster2);

        // now place the new merged cluster in the next available cell
        clusterNamesToIndices.put(cluster1 + cluster2, nextFreeColumn);

        nextFreeColumn++; // we just took up a new column

        // recalculate everything
        recalculateAfterMerge(cluster1,  cluster2);
    }

    /** Helper method to get the total number of entries in the table */
    public int getClusterCount() {
        return this.getIDs().size();
    }

    /** Gets the u-score for this cluster*/
    public double getUScore(String cluster) {
        if (! clusterNamesToIndices.containsKey(cluster)) {
            return Double.MIN_VALUE;
        }

        return uScores[clusterNamesToIndices.get(cluster)];
    }

    /** Sets the u-score for a given cluster*/
    public void setUScore(String cluster, double uscore) {
        if (! clusterNamesToIndices.containsKey(cluster))
            return;

        uScores[clusterNamesToIndices.get(cluster)] = uscore;
    }


    /** Get sum of distances to all other entries*/
    public double getSumDistances(String cluster) {
        double sum = 0;

        for (String other_cluster : getIDs()) {
            if (! other_cluster.equals(cluster)) { // skip ourselves
                sum += getDistance(cluster, other_cluster);
            }
        }

        return sum;
    }

    /** Helper method to get all of the clusters in this table*/
    public Set<String> getIDs() {
        return clusterNamesToIndices.keySet();
    }

    /**
     * Calculates the distance between a cluster and the combination of that
     * cluster and another (parent to child). We need this method since
     * this result is never actually stored in our uscore tables.
     * Note: You should not recalculate the u-scores before calling this method.
     */
    public double getDistanceAfterMerge(String c1, String c2) {
        return distanceCalculator.getDistanceAfterMerge(this, c1, c2);
    }

    /**
     * This method looks at two indicies for indexing into the distance
     * table and returns them in the proper order for a lower triangular matrix.
     * @return the two cluster indicies but in the proper ordering
     */
    protected int[] flipToProperOrdering(int c1Index, int c2Index) {

        if (c1Index < c2Index)
            return new int[] {c2Index, c1Index}; // need to flip the ordering
        else
            return new int[] {c1Index, c2Index}; // ordering is fine
    }
}
